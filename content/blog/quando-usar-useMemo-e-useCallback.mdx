---
title: "Quando usar useMemo e useCallback"
description: "Muitos dev react tem essa d√∫vida, incluindo eu."
date: "2025-08-12"
author: "Jorge Madson"
tags: ["React", "Frontend", "Development"]
image: "/placeholder.svg?height=200&width=400"
published: true
---
Vou explicar quando e como usar useMemo e useCallback
  corretamente. √â uma d√∫vida muito comum e importante para
  otimiza√ß√£o de performance no React.

###  üéØ Quando usar useMemo

  ‚úÖ USE quando:

  1. C√°lculos pesados que dependem de props/state:
  const ExpensiveComponent = ({ data, filter }) => {
    // ‚ùå Roda toda vez que o componente re-renderiza
    const filteredData = data.filter(item => item.category ===
  filter)

    // ‚úÖ S√≥ roda quando data ou filter mudam
    const filteredData = useMemo(
      () => data.filter(item => item.category === filter),
      [data, filter]
    )
  }

  2. Objetos/arrays que s√£o passados como props:
  const Parent = ({ users }) => {
    // ‚ùå Cria novo objeto toda vez = filho re-renderiza
    const config = { showAvatar: true, size: 'large' }

    // ‚úÖ Mesmo objeto = filho n√£o re-renderiza
    const config = useMemo(
      () => ({ showAvatar: true, size: 'large' }),
      []
    )

    return <UserList users={users} config={config} />
  }

  ‚ùå N√ÉO USE quando:

  1. Valores primitivos simples:
  // ‚ùå Desnecess√°rio - string √© barata
  const text = useMemo(() => `Hello ${name}`, [name])

  // ‚úÖ Mais simples e perform√°tico
  const text = `Hello ${name}`

###  üéØ Quando usar useCallback

  ‚úÖ USE quando:

  1. Fun√ß√µes passadas para componentes filhos:
  const Parent = ({ items }) => {
    // ‚ùå Nova fun√ß√£o toda vez = filho re-renderiza
    const handleClick = (id) => console.log(id)

    // ‚úÖ Mesma fun√ß√£o = filho n√£o re-renderiza
    const handleClick = useCallback(
      (id) => console.log(id),
      []
    )

    return items.map(item =>
      <ExpensiveChild key={item.id} onClick={handleClick} />
    )
  }

  2. Depend√™ncias de outros hooks:
  const SearchComponent = ({ query }) => {
    // ‚ùå useEffect roda toda vez
    const fetchData = () => api.search(query)

    useEffect(() => {
      fetchData()
    }, [fetchData]) // fetchData muda toda vez

    // ‚úÖ useEffect s√≥ roda quando query muda
    const fetchData = useCallback(
      () => api.search(query),
      [query]
    )

    useEffect(() => {
      fetchData()
    }, [fetchData])
  }

  ‚ùå N√ÉO USE quando:

  1. Fun√ß√£o n√£o √© passada para filhos:
  // ‚ùå Desnecess√°rio
  const handleClick = useCallback(() => {
    setCount(c => c + 1)
  }, [])

  // ‚úÖ Mais simples
  const handleClick = () => {
    setCount(c => c + 1)
  }

  üìù Exemplos Pr√°ticos do Nosso Projeto

  1. useMemo no useGitHubSearch:

  // ‚úÖ Evita recriar array toda vez
  const repos = useMemo(() => data || [], [data])

  // ‚úÖ Evita recalcular toda vez
  const hasNextPage = useMemo(() => repos.length === 12,
  [repos.length])

  2. useCallback no SearchBox:

  // ‚úÖ Evita recriar fun√ß√£o quando SearchBox re-renderiza
  const handleInputChange = useCallback((e) => {
    setUsername(e.target.value)
  }, [setUsername])

  3. useMemo no RepoList:

  // ‚úÖ Evita recalcular condi√ß√£o complexa
  const showPagination = useMemo(
    () => !isLoading && !error && repos.length > 0 &&
  (hasNextPage || hasPrevPage),
    [isLoading, error, repos.length, hasNextPage, hasPrevPage]
  )

  // ‚úÖ Evita recriar skeleton items
  const skeletonItems = useMemo(() =>
    Array.from({ length: 6 }).map((_, i) => (
      <div key={i} className="skeleton-loading h-28 rounded-lg" 
  />
    )),
    [] // Empty deps = s√≥ cria uma vez
  )

  üö® Regra de Ouro

  "N√£o otimize prematuramente"

  1. Primeiro: Escreva c√≥digo limpo e funcional
  2. Depois: Me√ßa performance (React DevTools Profiler)
  3. S√≥ ent√£o: Otimize onde realmente precisar

  üîç Como Identificar Onde Usar

  1. React DevTools Profiler - mostra componentes que
  re-renderizam muito
  2. Console.log em renders - v√™ quantas vezes roda
  3. Performance - se notou lentid√£o espec√≠fica

  ‚öñÔ∏è Custo vs Benef√≠cio

  // ‚ùå Overhead desnecess√°rio
  const simpleValue = useMemo(() => x + y, [x, y])

  // ‚úÖ Benef√≠cio real
  const expensiveCalculation = useMemo(() => {
    return heavyProcessing(largeDataSet)
  }, [largeDataSet])

  Resumo: Use quando o benef√≠cio de evitar rec√°lculo/re-render
  for maior que o overhead do hook. Na d√∫vida, comece sem e
  adicione se precisar!
